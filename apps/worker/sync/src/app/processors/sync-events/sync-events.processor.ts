import { Sync, SyncQueue } from "@badman/backend-queue";
import { PointsService } from "@badman/backend-ranking";
import { VisualService, XmlTournament, XmlTournamentTypeID } from "@badman/backend-visual";
import { Process, Processor } from "@nestjs/bull";
import { Logger } from "@nestjs/common";
import { Job } from "bull";
import { Sequelize } from "sequelize-typescript";
import { CompetitionSyncer } from "./competition-sync";
import { TournamentSyncer } from "./tournament-sync";
import moment from "moment";
import { NotificationService } from "@badman/backend-notifications";
import { CronJob, EventCompetition, EventTournament } from "@badman/backend-database";

@Processor({
  name: SyncQueue,
})
export class SyncEventsProcessor {
  private _competitionSync: CompetitionSyncer;
  private _tournamentSync: TournamentSyncer;

  private readonly logger = new Logger(SyncEventsProcessor.name);
  private formats = [
    "https://www.toernooi.nl/sport/league?id=",
    "https://www.badmintonvlaanderen.be/sport/tournament?id=",
    "https://www.toernooi.nl/tournament/",
    "https://www.badmintonvlaanderen.be/tournament/",
  ];

  constructor(
    pointService: PointsService,
    private notificationService: NotificationService,
    private visualService: VisualService,
    private _sequelize: Sequelize
  ) {
    this._competitionSync = new CompetitionSyncer(this.visualService, pointService);
    this._tournamentSync = new TournamentSyncer(this.visualService, pointService);
  }

  @Process(Sync.SyncEvents)
  async syncEvents(
    job: Job<{
      // Changed after date
      date?: Date;
      // Start from certain date
      startDate?: Date;
      // Skip types / event names
      skip: string[];
      // Search for namne
      search: string;
      // Exact id
      id: string | string[];
      // Official
      official?: boolean;
      // Only types / event names
      only: string[];
      // Continue from a previous (failed) run
      offset: number;
      // Only process a certain number of events
      limit: number;
      // the to notifiy user
      userId?: string | string[];
    }>
  ) {
    const cronJob = await CronJob.findOne({
      where: {
        "meta.jobName": Sync.SyncEvents,
        "meta.queueName": SyncQueue,
      },
    });

    if (!cronJob) {
      throw new Error("Job not found");
    }

    cronJob.amount++;
    await cronJob.save();

    try {
      // Creates a new date based on either the job's date parameter or the last run time
      const newDate = moment(job.data?.date ?? cronJob.lastRun);
      let newEvents: XmlTournament[] = [];

      // Checks if the search term is present in the job data.  If so, we will search for events based on the search term
      const searchTermPresent = job.data?.search?.length > 0;
      // Checks if a specific event id is present in the job data.  If so, we will process the event with specified id
      const idPresent = job.data?.id?.length > 0;

      if (searchTermPresent) {
        newEvents = newEvents.concat(await this.visualService.searchEvents(job.data?.search));
      } else if (idPresent) {
        // If the id is not an array, convert it to an array, so we can loop through it
        if (!Array.isArray(job.data?.id)) {
          job.data.id = [job.data.id];
        }

        for (let id of job.data?.id as string[]) {
          for (const format of this.formats) {
            if (id.startsWith(format)) {
              id = id.replace(format, "");
              break;
            }
          }

          newEvents = newEvents.concat(await this.visualService.getEvent(id));
        }
      } else {
        newEvents = newEvents.concat(await this.visualService.getChangeEvents(newDate));
      }
      newEvents = newEvents.sort((a, b) => {
        return moment(a.StartDate).valueOf() - moment(b.StartDate).valueOf();
      });

      this.logger.verbose(`Found ${newEvents.length} new events`);

      if (job.data?.startDate) {
        newEvents = newEvents.filter((e) => {
          return moment(e.StartDate).isSameOrAfter(job.data?.startDate);
        });
      }

      this.logger.verbose(`Found ${newEvents.length} new events after ${job.data?.startDate}`);

      let toProcess = newEvents.length;
      if (job.data?.limit) {
        toProcess = job.data?.offset ?? 0 + job.data?.limit;
      }

      this.logger.debug(`Processing ${toProcess} events`);

      for (let i = job.data?.offset ?? 0; i < toProcess; i++) {
        const xmlTournament = newEvents[i];
        const current = i + 1;
        const total = toProcess;
        const percent = Math.round((current / total) * 10000) / 100;
        job.progress(percent);
        this.logger.debug(`Processing ${xmlTournament?.Name}, ${percent}% (${i}/${total})`);

        // Skip certain event
        if ((job.data?.skip?.length ?? 0) > 0 && job.data?.skip?.includes(xmlTournament?.Name)) {
          continue;
        }

        // Only process certain events
        if ((job.data?.only?.length ?? 0) > 0 && !job.data?.only?.includes(xmlTournament?.Name)) {
          continue;
        }

        const transaction = await this._sequelize.transaction();

        try {
          let resultData: { event: EventCompetition | EventTournament } | null = null;
          if (
            xmlTournament.TypeID === XmlTournamentTypeID.OnlineLeague ||
            xmlTournament.TypeID === XmlTournamentTypeID.TeamTournament
          ) {
            // // National is a bit different have to lookinto, temp skip
            // if (xmlTournament?.Name?.includes('Victor League')) {
            //   continue;
            // }

            if (!job.data?.skip?.includes("competition")) {
              resultData = (await this._competitionSync.process({
                transaction,
                xmlTournament,
                options: { ...job.data },
              })) as { event: EventCompetition };
            }
          } else {
            if (!job.data?.skip?.includes("tournament")) {
              resultData = (await this._tournamentSync.process({
                transaction,
                xmlTournament,
                options: { ...job.data },
              })) as { event: EventTournament };
            }
          }
          this.logger.debug(`Committing transaction`);
          await transaction.commit();
          this.logger.log(`Finished ${xmlTournament?.Name}`);

          if (job.data?.userId) {
            const userIds = Array.isArray(job.data?.userId) ? job.data?.userId : [job.data?.userId];

            for (const userId of userIds) {
              await this.notificationService.notifySyncFinished(userId, {
                event: resultData?.event,
                success: true,
              });
            }
          }
        } catch (e) {
          this.logger.error("Rollback", e);
          await transaction.rollback();

          if (job.data?.userId) {
            const userIds = Array.isArray(job.data?.userId) ? job.data?.userId : [job.data?.userId];

            for (const userId of userIds) {
              await this.notificationService.notifySyncFinished(userId, {
                event: {
                  name: xmlTournament.Name,
                } as EventTournament,
                success: false,
              });
            }
          }
          throw e;
        }
      }
    } catch (e) {
      this.logger.error("Error", e);

      throw e;
    } finally {
      cronJob.amount--;
      cronJob.lastRun = new Date();
      await cronJob.save();
    }

    this.logger.log("Finished sync of Visual scores");
  }
}
